# Анализ кодовой базы и возможные улучшения

## Суть проекта (Project Essence)
**Multi-Agent CLI Orchestrator** — это всегда работающий оркестратор задач (jobs) для координации headless CLI-агентов (OpenCode / Claude Code / Codex). 
Ключевая идея проекта заключается в предоставлении **MVP (Minimum Viable Product)** с нулевой конфигурацией:
1.  **Отсутствие базы данных (Stateless runner):** Хранилище состояния основано исключительно на файловой системе (`artifacts/` и `var/queue/`).
2.  **Файловая очередь (fsqueue):** Управление очередью реализовано через атомарное перемещение (`os.replace`) JSON-файлов между директориями. Разделение очередей на папки (`pending`, `running`, `done` и т.д.) позволяет избежать блокировок на уровне БД.
3.  **Фиксированная структура артефактов:** Строгая конвенция по файлам: `report.md`, `patch.diff`, `logs.txt`, `result.json`. Это позволяет унифицировать выходные данные разных LLM-агентов и CLI-утилит.
4.  **Секьюрность по умолчанию:** Предлагается режим симуляции («из коробки»), а для реального запуска CLI применяются белые списки бинарников (`ALLOWED_BINARIES`), фильтрация переменных окружения (`ENV_ALLOWLIST`) и примитивы песочницы.

---

## Архитектурный анализ текущего решения

### Плюсы:
-   **Низкий порог входа:** Полное отсутствие зависимости от внешних брокеров (Redis/RabbitMQ) или баз данных. Запускается `make dev` за секунды.
-   **Реально работающая механика агентов:** Оркестратор успешно забирает job'ы из очереди, прогоняет шаги пайплайна и вызывает воркеры агентов через слой `AgentExecutor` (`sys-запуски` через `subprocess`).
-   **Изоляция и контроль:** Каждая job/step имеет строгий набор артефактов, лимиты на размер входа (input artifacts constraints) и очистку токенов из логов (через `log_sanitizer.py`).
-   **Четкие контракты:** Использование Pydantic (модели `JobSpec`, `StepSpec`) и JSON Schemas для входного Gateway (FastAPI).

### Узкие места (Bottlenecks):
-   **Производительность fsqueue:** Сортировка файлов на диске через `glob()`, выборка задач по `mtime` и создание `.tmp` файлов при высокой нагрузке создадут высокую I/O нагрузку и проблемы с FIFO при одновременной записи. Бесконечный `polling` через `asyncio.sleep` в Runner'е создает лишнюю нагрузку и задержки.
-   **Отсутствие БД:** Ограничивает создание админок / дашбордов для поиска, агрегации и фильтрации истории задач. 

---

## Доведение до "Production-ish": Улучшения механики Агентов

Чтобы оркестратор *надежно* запускал других агентов, необходимы улучшения в механизмах передачи контекста и управления доступом. (Все текущие задачи выполнены)

---

## Доведение до "Production-ish": Архитектура и Масштабируемость

1.  **Подсистема очередей (SQLite / Inotify):**
    Заменить файловую очередь (`fsqueue`) на встроенную **SQLite** базу (сохраняет концепт "0 setup"), либо перейти с пуллинга файлов (`while True: sleep`) на Watchdog/Inotify. Это обеспечит транзакции, строгое FIFO по автоинкременту и уберет "пустую" трату CPU.
    - *Статус: Запланировано (В планах на будущее).*

---

## Доведение до "Production-ish": Security & Observability

Задачи по безопасности шлюза и защите воркспейса выполнены.

---
**Итог:** Почти все критичные архитектурные задачи из первоначального анализа завершены. Оркестратор успешно достиг безопасного, легко масштабируемого MVP. Оставшаяся амбициозная задача — переход на SQLite-очередь — является опциональной и потребуется только при кратно высоких нагрузках.
